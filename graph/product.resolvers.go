package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/SarunasBucius/nutri-price-server/graph/model"
	"github.com/jackc/pgx/v5/pgtype"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductAggregateInput) (string, error) {
	query := `
	INSERT INTO products (name)
	VALUES ($1)
	ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
	RETURNING id`
	var productID string
	if err := r.DB.QueryRow(ctx, query, input.Name).Scan(&productID); err != nil {
		return "", fmt.Errorf("insert product: %w", err)
	}

	if productID == "" {
		return "", fmt.Errorf("product id is empty")
	}

	varietyName := input.VarietyName
	if varietyName == "" {
		varietyName = input.Name
	}

	if input.NutritionalValue != nil {
		query = `
				INSERT INTO nutritional_values_v2 (product_id, variety_name, unit, energy_value_kcal, fat, saturated_fat, carbohydrate, carbohydrate_sugars, fibre, protein, salt)
				VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) ON CONFLICT (variety_name, product_id) 
				DO UPDATE SET     
					unit = EXCLUDED.unit,
					energy_value_kcal = EXCLUDED.energy_value_kcal,
					fat = EXCLUDED.fat,
					saturated_fat = EXCLUDED.saturated_fat,
					carbohydrate = EXCLUDED.carbohydrate,
					carbohydrate_sugars = EXCLUDED.carbohydrate_sugars,
					fibre = EXCLUDED.fibre,
					protein = EXCLUDED.protein,
					salt = EXCLUDED.salt`
		nv := input.NutritionalValue
		if _, err := r.DB.Exec(ctx, query, productID, varietyName, nv.Unit,
			nv.EnergyValueKcal, nv.Fat,
			nv.SaturatedFat, nv.Carbohydrate,
			nv.CarbohydrateSugars, nv.Fibre,
			nv.Protein, nv.Salt); err != nil {
			return "", fmt.Errorf("insert nutritional value: %w", err)
		}
	}

	if input.Purchase != nil {
		query = `
		INSERT INTO purchases (product_id, variety_name, retailer, purchase_date, quantity, unit, price, notes)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`
		purchase := input.Purchase
		if _, err := r.DB.Exec(ctx, query, productID, varietyName, purchase.Retailer,
			purchase.Date, purchase.Quantity, purchase.Unit,
			purchase.Price, purchase.Notes); err != nil {
			return "", fmt.Errorf("insert purchase: %w", err)
		}
	}

	return productID, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, name string) (string, error) {
	query := `
	UPDATE products
	SET name = $1
	WHERE id = $2`
	if _, err := r.DB.Exec(ctx, query, name, id); err != nil {
		return "", fmt.Errorf("update product: %w", err)
	}
	return id, nil
}

// UpdateVariety is the resolver for the updateVariety field.
func (r *mutationResolver) UpdateVariety(ctx context.Context, oldName string, varietyName string) (string, error) {
	query := `
	UPDATE nutritional_values_v2
	SET variety_name = $1
	WHERE variety_name = $2`
	if _, err := r.DB.Exec(ctx, query, varietyName, oldName); err != nil {
		return "", fmt.Errorf("update nutritional values variety name: %w", err)
	}
	query = `
	UPDATE purchases
	SET variety_name = $1
	WHERE variety_name = $2`
	if _, err := r.DB.Exec(ctx, query, varietyName, oldName); err != nil {
		return "", fmt.Errorf("update purchases variety name: %w", err)
	}
	return varietyName, nil
}

// UpdatePurchase is the resolver for the updatePurchase field.
func (r *mutationResolver) UpdatePurchase(ctx context.Context, id string, input model.PurchaseInput) (string, error) {
	query := `
	UPDATE purchases
	SET retailer = $1, purchase_date = $2, quantity = $3, unit = $4, price = $5, notes = $6
	WHERE id = $7`
	if _, err := r.DB.Exec(ctx, query, input.Retailer, input.Date,
		input.Quantity, input.Unit, input.Price, input.Notes, id); err != nil {
		return "", fmt.Errorf("update purchase: %w", err)
	}
	return id, nil
}

// UpsertNutritionalValue is the resolver for the upsertNutritionalValue field.
func (r *mutationResolver) UpsertNutritionalValue(ctx context.Context, productID string, varietyName string, input model.NutritionalValueInput) (string, error) {
	query := `
	INSERT INTO nutritional_values_v2 (product_id, variety_name, unit, energy_value_kcal, fat, saturated_fat, carbohydrate, carbohydrate_sugars, fibre, protein, salt)
	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) ON CONFLICT (variety_name, product_id) 
	DO UPDATE SET     
		unit = EXCLUDED.unit,
		energy_value_kcal = EXCLUDED.energy_value_kcal,
		fat = EXCLUDED.fat,
		saturated_fat = EXCLUDED.saturated_fat,
		carbohydrate = EXCLUDED.carbohydrate,
		carbohydrate_sugars = EXCLUDED.carbohydrate_sugars,
		fibre = EXCLUDED.fibre,
		protein = EXCLUDED.protein,
		salt = EXCLUDED.salt
	RETURNING id`

	var id string
	if err := r.DB.QueryRow(ctx, query, productID, varietyName, input.Unit,
		input.EnergyValueKcal, input.Fat,
		input.SaturatedFat, input.Carbohydrate,
		input.CarbohydrateSugars, input.Fibre,
		input.Protein, input.Salt).Scan(&id); err != nil {
		return "", fmt.Errorf("upsert nutritional value: %w", err)
	}
	return id, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (string, error) {
	query := `
	DELETE FROM products
	WHERE id = $1`
	if _, err := r.DB.Exec(ctx, query, id); err != nil {
		return "", fmt.Errorf("delete product: %w", err)
	}
	return id, nil
}

// DeleteVariety is the resolver for the deleteVariety field.
func (r *mutationResolver) DeleteVariety(ctx context.Context, varietyName string) (string, error) {
	query := `
	DELETE FROM nutritional_values_v2
	WHERE variety_name = $1`
	if _, err := r.DB.Exec(ctx, query, varietyName); err != nil {
		return "", fmt.Errorf("delete nutritional values by variety: %w", err)
	}

	query = `
	DELETE FROM purchases
	WHERE variety_name = $1`
	if _, err := r.DB.Exec(ctx, query, varietyName); err != nil {
		return "", fmt.Errorf("delete purchases by variety: %w", err)
	}
	return varietyName, nil
}

// DeletePurchase is the resolver for the deletePurchase field.
func (r *mutationResolver) DeletePurchase(ctx context.Context, id string) (string, error) {
	query := `
	DELETE FROM purchases
	WHERE id = $1`
	if _, err := r.DB.Exec(ctx, query, id); err != nil {
		return "", fmt.Errorf("delete purchase: %w", err)
	}
	return id, nil
}

// DeleteNutritionalValue is the resolver for the deleteNutritionalValue field.
func (r *mutationResolver) DeleteNutritionalValue(ctx context.Context, id string) (string, error) {
	query := `
	DELETE FROM nutritional_values_v2
	WHERE id = $1`
	if _, err := r.DB.Exec(ctx, query, id); err != nil {
		return "", fmt.Errorf("delete nutritional value: %w", err)
	}
	return id, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, name FROM products ORDER BY name")
	if err != nil {
		return nil, fmt.Errorf("query db: %w", err)
	}
	defer rows.Close()

	summaries := make([]*model.Product, 0)
	for rows.Next() {
		var id string
		var name string
		if err := rows.Scan(&id, &name); err != nil {
			return nil, fmt.Errorf("scan db: %w", err)
		}
		summaries = append(summaries, &model.Product{
			ID:   id,
			Name: name,
		})
	}
	return summaries, nil
}

// ProductAggregate is the resolver for the productAggregate field.
func (r *queryResolver) ProductAggregate(ctx context.Context, id string) (*model.ProductAggregate, error) {
	fieldsSet := make(map[string]struct{})
	for _, field := range graphql.CollectFields(graphql.GetOperationContext(ctx), graphql.GetFieldContext(ctx).Field.SelectionSet, nil) {
		fieldsSet[field.Name] = struct{}{}
		for _, nestedField := range graphql.CollectFields(graphql.GetOperationContext(ctx), field.SelectionSet, nil) {
			fieldsSet[nestedField.Name] = struct{}{}
		}
	}

	product := &model.ProductAggregate{}
	err := r.DB.QueryRow(ctx, "SELECT name FROM products WHERE id=$1", id).Scan(&product.Name)
	if err != nil {
		return nil, fmt.Errorf("query product name: %w", err)
	}

	query := `
		SELECT variety_name FROM purchases WHERE product_id = $1
		UNION
		SELECT variety_name FROM nutritional_values_v2 WHERE product_id = $1 
		ORDER BY variety_name`
	rows, err := r.DB.Query(ctx, query, id)
	if err != nil {
		return nil, fmt.Errorf("query variety names and ids: %w", err)
	}
	defer rows.Close()

	varieties := make([]*model.Variety, 0)
	for rows.Next() {
		variety := &model.Variety{}
		if err := rows.Scan(&variety.VarietyName); err != nil {
			return nil, fmt.Errorf("scan variety name and id: %w", err)
		}
		varieties = append(varieties, variety)
	}

	product.Varieties = varieties

	nvs := make(map[string]*model.NutritionalValue)
	if _, ok := fieldsSet["nutritionalValue"]; ok {
		query := `
		SELECT id, variety_name, unit, energy_value_kcal, fat, saturated_fat, carbohydrate, carbohydrate_sugars, fibre, protein, salt
		FROM nutritional_values_v2
		WHERE product_id=$1`
		rows, err := r.DB.Query(ctx, query, id)
		if err != nil {
			return nil, fmt.Errorf("query nutritional values: %w", err)
		}
		defer rows.Close()

		for rows.Next() {
			nv := &model.NutritionalValue{}
			var varietyName string
			if err := rows.Scan(&nv.ID, &varietyName, &nv.Unit, &nv.EnergyValueKcal,
				&nv.Fat, &nv.SaturatedFat, &nv.Carbohydrate, &nv.CarbohydrateSugars,
				&nv.Fibre, &nv.Protein, &nv.Salt); err != nil {
				return nil, fmt.Errorf("scan nutritional value: %w", err)
			}
			nvs[varietyName] = nv
		}
	}

	purchases := make(map[string][]*model.Purchase)
	if _, ok := fieldsSet["purchases"]; ok {
		query := `
		SELECT id, variety_name, retailer, purchase_date, quantity, unit, price, notes
		FROM purchases
		WHERE product_id=$1`
		rows, err := r.DB.Query(ctx, query, id)
		if err != nil {
			return nil, fmt.Errorf("query purchases: %w", err)
		}
		defer rows.Close()

		for rows.Next() {
			purchase := &model.Purchase{}
			var date *pgtype.Date
			var varietyName string
			if err := rows.Scan(&purchase.ID, &varietyName, &purchase.Retailer, &date,
				&purchase.Quantity, &purchase.Unit, &purchase.Price, &purchase.Notes); err != nil {
				return nil, fmt.Errorf("scan purchase: %w", err)
			}
			if date != nil {
				purchase.Date = date.Time.Format(time.DateOnly)
			}
			purchases[varietyName] = append(purchases[varietyName], purchase)
		}
	}
	for _, variety := range product.Varieties {
		if nv, ok := nvs[variety.VarietyName]; ok {
			variety.NutritionalValue = nv
		}
		if purchaseList, ok := purchases[variety.VarietyName]; ok {
			variety.Purchases = purchaseList
		}
	}
	return product, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
