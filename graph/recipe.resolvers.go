package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"strconv"

	"github.com/SarunasBucius/nutri-price-server/graph/model"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// UpdateRecipe is the resolver for the updateRecipe field.
func (r *mutationResolver) UpdateRecipe(ctx context.Context, recipe model.RecipeInput) (string, error) {
	dbRecipe, err := attributevalue.MarshalMap(recipe)
	if err != nil {
		return "", fmt.Errorf("marshal recipe: %w", err)
	}

	if _, err := r.DynamoDB.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("Recipes"),
		Item:      dbRecipe,
	}); err != nil {
		return "", fmt.Errorf("update item: %w", err)
	}

	return recipe.RecipeName, nil
}

// UpdatePreparedRecipe is the resolver for the updatePreparedRecipe field.
func (r *mutationResolver) UpdatePreparedRecipe(ctx context.Context, recipe model.PreparedRecipeInput) (string, error) {
	dbRecipe, err := attributevalue.MarshalMap(recipe)
	if err != nil {
		return "", fmt.Errorf("marshal recipe: %w", err)
	}

	if _, err := r.DynamoDB.PutItem(ctx, &dynamodb.PutItemInput{
		TableName: aws.String("PreparedRecipes"),
		Item:      dbRecipe,
	}); err != nil {
		return "", fmt.Errorf("update item: %w", err)
	}

	return recipe.RecipeName, nil
}

// PlanRecipes is the resolver for the planRecipes field.
func (r *mutationResolver) PlanRecipes(ctx context.Context, date string, planRecipes []*model.PlanRecipe) (string, error) {
	recipeNames := make([]map[string]types.AttributeValue, 0, len(planRecipes))
	portionByName := make(map[string]float64, len(planRecipes))
	for _, recipe := range planRecipes {
		recipeNames = append(recipeNames, map[string]types.AttributeValue{
			"RecipeName": &types.AttributeValueMemberS{Value: recipe.RecipeName}})
		portionByName[recipe.RecipeName] = recipe.Portion
	}

	getBatchRecipes, err := r.DynamoDB.BatchGetItem(ctx, &dynamodb.BatchGetItemInput{
		RequestItems: map[string]types.KeysAndAttributes{
			"Recipes": {
				Keys: recipeNames,
			},
		},
	})
	if err != nil {
		return "", fmt.Errorf("batch get items: %w", err)
	}

	putRequests := make([]types.WriteRequest, 0, len(getBatchRecipes.Responses["Recipes"]))
	for i := range getBatchRecipes.Responses["Recipes"] {
		recipe := getBatchRecipes.Responses["Recipes"][i]
		var recipeName string
		if err := attributevalue.Unmarshal(recipe["RecipeName"], &recipeName); err != nil {
			return "", fmt.Errorf("unmarshal recipe name: %w", err)
		}
		portion := strconv.FormatFloat(portionByName[recipeName], 'f', 1, 64)
		recipe["Portion"] = &types.AttributeValueMemberN{Value: portion}
		recipe["PreparedDate"] = &types.AttributeValueMemberS{Value: date}

		putRequests = append(putRequests, types.WriteRequest{
			PutRequest: &types.PutRequest{
				Item: recipe,
			}})
	}

	if _, err = r.DynamoDB.BatchWriteItem(ctx, &dynamodb.BatchWriteItemInput{
		RequestItems: map[string][]types.WriteRequest{
			"PreparedRecipes": putRequests,
		},
	}); err != nil {
		return "", fmt.Errorf("batch write items: %w", err)
	}

	return "Prepared recipes were inserted successfully", nil
}

// Recipes is the resolver for the recipes field.
func (r *queryResolver) Recipes(ctx context.Context) ([]string, error) {
	res, err := r.DynamoDB.Scan(ctx, &dynamodb.ScanInput{
		TableName:            aws.String("Recipes"),
		Select:               types.SelectSpecificAttributes,
		ProjectionExpression: aws.String("RecipeName"),
	})
	if err != nil {
		return nil, fmt.Errorf("query items: %w", err)
	}

	recipes := make([]string, 0, len(res.Items))
	for _, recipe := range res.Items {
		var recipeName string
		if err := attributevalue.Unmarshal(recipe["RecipeName"], &recipeName); err != nil {
			return nil, fmt.Errorf("unmarshal recipe name: %w", err)
		}
		recipes = append(recipes, recipeName)
	}

	return recipes, nil
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, recipeName string) (*model.RecipeAggregate, error) {
	res, err := r.DynamoDB.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String("Recipes"),
		Key: map[string]types.AttributeValue{
			"RecipeName": &types.AttributeValueMemberS{Value: recipeName},
		},
	})
	if err != nil {
		return nil, fmt.Errorf("get item: %w", err)
	}
	var recipe model.RecipeAggregate
	if err := attributevalue.UnmarshalMap(res.Item, &recipe); err != nil {
		return nil, fmt.Errorf("unmarshal item: %w", err)
	}
	return &recipe, nil
}

// PreparedRecipesByDate is the resolver for the preparedRecipesByDate field.
func (r *queryResolver) PreparedRecipesByDate(ctx context.Context, date string) ([]string, error) {
	res, err := r.DynamoDB.Query(ctx, &dynamodb.QueryInput{
		TableName:              aws.String("PreparedRecipes"),
		KeyConditionExpression: aws.String("PreparedDate = :date"),
		ExpressionAttributeValues: map[string]types.AttributeValue{
			":date": &types.AttributeValueMemberS{Value: date},
		},
		Select:               types.SelectSpecificAttributes,
		ProjectionExpression: aws.String("RecipeName"),
	})
	if err != nil {
		return nil, fmt.Errorf("query items: %w", err)
	}

	recipes := make([]string, 0, len(res.Items))
	for _, recipe := range res.Items {
		var recipeName string
		if err := attributevalue.Unmarshal(recipe["RecipeName"], &recipeName); err != nil {
			return nil, fmt.Errorf("unmarshal recipe name: %w", err)
		}
		recipes = append(recipes, recipeName)
	}

	return recipes, nil
}

// PreparedRecipe is the resolver for the preparedRecipe field.
func (r *queryResolver) PreparedRecipe(ctx context.Context, recipeName string, date string) (*model.PreparedRecipeAggregate, error) {
	res, err := r.DynamoDB.GetItem(ctx, &dynamodb.GetItemInput{
		TableName: aws.String("PreparedRecipes"),
		Key: map[string]types.AttributeValue{
			"RecipeName":   &types.AttributeValueMemberS{Value: recipeName},
			"PreparedDate": &types.AttributeValueMemberS{Value: date},
		},
	})
	if err != nil {
		return nil, fmt.Errorf("get item: %w", err)
	}
	var recipe model.PreparedRecipeAggregate
	if err := attributevalue.UnmarshalMap(res.Item, &recipe); err != nil {
		return nil, fmt.Errorf("unmarshal item: %w", err)
	}
	return &recipe, nil
}
