// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/SarunasBucius/nutri-price-server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Ingredient struct {
		Notes    func(childComplexity int) int
		Product  func(childComplexity int) int
		Quantity func(childComplexity int) int
		Unit     func(childComplexity int) int
	}

	Mutation struct {
		CreateProduct          func(childComplexity int, input model.ProductAggregateInput) int
		DeleteNutritionalValue func(childComplexity int, id string) int
		DeleteProduct          func(childComplexity int, id string) int
		DeletePurchase         func(childComplexity int, id string) int
		DeleteVariety          func(childComplexity int, varietyName string) int
		PlanRecipes            func(childComplexity int, date string, planRecipes []*model.PlanRecipe) int
		UpdatePreparedRecipe   func(childComplexity int, recipe model.PreparedRecipeInput) int
		UpdateProduct          func(childComplexity int, id string, name string) int
		UpdatePurchase         func(childComplexity int, id string, input model.PurchaseInput) int
		UpdateRecipe           func(childComplexity int, recipe model.RecipeInput) int
		UpdateVariety          func(childComplexity int, oldName string, varietyName string) int
		UpsertNutritionalValue func(childComplexity int, productID string, varietyName string, input model.NutritionalValueInput) int
	}

	NutritionalValue struct {
		Carbohydrate       func(childComplexity int) int
		CarbohydrateSugars func(childComplexity int) int
		EnergyValueKcal    func(childComplexity int) int
		Fat                func(childComplexity int) int
		Fibre              func(childComplexity int) int
		ID                 func(childComplexity int) int
		Protein            func(childComplexity int) int
		Salt               func(childComplexity int) int
		SaturatedFat       func(childComplexity int) int
		Unit               func(childComplexity int) int
	}

	PreparedRecipeAggregate struct {
		Ingredients  func(childComplexity int) int
		Notes        func(childComplexity int) int
		Portion      func(childComplexity int) int
		PreparedDate func(childComplexity int) int
		RecipeName   func(childComplexity int) int
		Steps        func(childComplexity int) int
	}

	Product struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	ProductAggregate struct {
		Name      func(childComplexity int) int
		Varieties func(childComplexity int) int
	}

	Purchase struct {
		Date     func(childComplexity int) int
		ID       func(childComplexity int) int
		Notes    func(childComplexity int) int
		Price    func(childComplexity int) int
		Quantity func(childComplexity int) int
		Retailer func(childComplexity int) int
		Unit     func(childComplexity int) int
	}

	Query struct {
		PreparedRecipe        func(childComplexity int, recipeName string, date string) int
		PreparedRecipesByDate func(childComplexity int, date string) int
		ProductAggregate      func(childComplexity int, id string) int
		Products              func(childComplexity int) int
		Recipe                func(childComplexity int, recipeName string) int
		Recipes               func(childComplexity int) int
	}

	RecipeAggregate struct {
		Ingredients func(childComplexity int) int
		Notes       func(childComplexity int) int
		RecipeName  func(childComplexity int) int
		Steps       func(childComplexity int) int
	}

	Variety struct {
		NutritionalValue func(childComplexity int) int
		Purchases        func(childComplexity int) int
		VarietyName      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Ingredient.notes":
		if e.complexity.Ingredient.Notes == nil {
			break
		}

		return e.complexity.Ingredient.Notes(childComplexity), true

	case "Ingredient.product":
		if e.complexity.Ingredient.Product == nil {
			break
		}

		return e.complexity.Ingredient.Product(childComplexity), true

	case "Ingredient.quantity":
		if e.complexity.Ingredient.Quantity == nil {
			break
		}

		return e.complexity.Ingredient.Quantity(childComplexity), true

	case "Ingredient.unit":
		if e.complexity.Ingredient.Unit == nil {
			break
		}

		return e.complexity.Ingredient.Unit(childComplexity), true

	case "Mutation.createProduct":
		if e.complexity.Mutation.CreateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_createProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProduct(childComplexity, args["input"].(model.ProductAggregateInput)), true

	case "Mutation.deleteNutritionalValue":
		if e.complexity.Mutation.DeleteNutritionalValue == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNutritionalValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNutritionalValue(childComplexity, args["id"].(string)), true

	case "Mutation.deleteProduct":
		if e.complexity.Mutation.DeleteProduct == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProduct(childComplexity, args["id"].(string)), true

	case "Mutation.deletePurchase":
		if e.complexity.Mutation.DeletePurchase == nil {
			break
		}

		args, err := ec.field_Mutation_deletePurchase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePurchase(childComplexity, args["id"].(string)), true

	case "Mutation.deleteVariety":
		if e.complexity.Mutation.DeleteVariety == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVariety_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVariety(childComplexity, args["varietyName"].(string)), true

	case "Mutation.planRecipes":
		if e.complexity.Mutation.PlanRecipes == nil {
			break
		}

		args, err := ec.field_Mutation_planRecipes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PlanRecipes(childComplexity, args["date"].(string), args["planRecipes"].([]*model.PlanRecipe)), true

	case "Mutation.updatePreparedRecipe":
		if e.complexity.Mutation.UpdatePreparedRecipe == nil {
			break
		}

		args, err := ec.field_Mutation_updatePreparedRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePreparedRecipe(childComplexity, args["recipe"].(model.PreparedRecipeInput)), true

	case "Mutation.updateProduct":
		if e.complexity.Mutation.UpdateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_updateProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProduct(childComplexity, args["id"].(string), args["name"].(string)), true

	case "Mutation.updatePurchase":
		if e.complexity.Mutation.UpdatePurchase == nil {
			break
		}

		args, err := ec.field_Mutation_updatePurchase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePurchase(childComplexity, args["id"].(string), args["input"].(model.PurchaseInput)), true

	case "Mutation.updateRecipe":
		if e.complexity.Mutation.UpdateRecipe == nil {
			break
		}

		args, err := ec.field_Mutation_updateRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecipe(childComplexity, args["recipe"].(model.RecipeInput)), true

	case "Mutation.updateVariety":
		if e.complexity.Mutation.UpdateVariety == nil {
			break
		}

		args, err := ec.field_Mutation_updateVariety_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVariety(childComplexity, args["oldName"].(string), args["varietyName"].(string)), true

	case "Mutation.upsertNutritionalValue":
		if e.complexity.Mutation.UpsertNutritionalValue == nil {
			break
		}

		args, err := ec.field_Mutation_upsertNutritionalValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertNutritionalValue(childComplexity, args["productID"].(string), args["varietyName"].(string), args["input"].(model.NutritionalValueInput)), true

	case "NutritionalValue.carbohydrate":
		if e.complexity.NutritionalValue.Carbohydrate == nil {
			break
		}

		return e.complexity.NutritionalValue.Carbohydrate(childComplexity), true

	case "NutritionalValue.carbohydrateSugars":
		if e.complexity.NutritionalValue.CarbohydrateSugars == nil {
			break
		}

		return e.complexity.NutritionalValue.CarbohydrateSugars(childComplexity), true

	case "NutritionalValue.energyValueKcal":
		if e.complexity.NutritionalValue.EnergyValueKcal == nil {
			break
		}

		return e.complexity.NutritionalValue.EnergyValueKcal(childComplexity), true

	case "NutritionalValue.fat":
		if e.complexity.NutritionalValue.Fat == nil {
			break
		}

		return e.complexity.NutritionalValue.Fat(childComplexity), true

	case "NutritionalValue.fibre":
		if e.complexity.NutritionalValue.Fibre == nil {
			break
		}

		return e.complexity.NutritionalValue.Fibre(childComplexity), true

	case "NutritionalValue.id":
		if e.complexity.NutritionalValue.ID == nil {
			break
		}

		return e.complexity.NutritionalValue.ID(childComplexity), true

	case "NutritionalValue.protein":
		if e.complexity.NutritionalValue.Protein == nil {
			break
		}

		return e.complexity.NutritionalValue.Protein(childComplexity), true

	case "NutritionalValue.salt":
		if e.complexity.NutritionalValue.Salt == nil {
			break
		}

		return e.complexity.NutritionalValue.Salt(childComplexity), true

	case "NutritionalValue.saturatedFat":
		if e.complexity.NutritionalValue.SaturatedFat == nil {
			break
		}

		return e.complexity.NutritionalValue.SaturatedFat(childComplexity), true

	case "NutritionalValue.unit":
		if e.complexity.NutritionalValue.Unit == nil {
			break
		}

		return e.complexity.NutritionalValue.Unit(childComplexity), true

	case "PreparedRecipeAggregate.ingredients":
		if e.complexity.PreparedRecipeAggregate.Ingredients == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Ingredients(childComplexity), true

	case "PreparedRecipeAggregate.notes":
		if e.complexity.PreparedRecipeAggregate.Notes == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Notes(childComplexity), true

	case "PreparedRecipeAggregate.portion":
		if e.complexity.PreparedRecipeAggregate.Portion == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Portion(childComplexity), true

	case "PreparedRecipeAggregate.preparedDate":
		if e.complexity.PreparedRecipeAggregate.PreparedDate == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.PreparedDate(childComplexity), true

	case "PreparedRecipeAggregate.recipeName":
		if e.complexity.PreparedRecipeAggregate.RecipeName == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.RecipeName(childComplexity), true

	case "PreparedRecipeAggregate.steps":
		if e.complexity.PreparedRecipeAggregate.Steps == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Steps(childComplexity), true

	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true

	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "ProductAggregate.name":
		if e.complexity.ProductAggregate.Name == nil {
			break
		}

		return e.complexity.ProductAggregate.Name(childComplexity), true

	case "ProductAggregate.varieties":
		if e.complexity.ProductAggregate.Varieties == nil {
			break
		}

		return e.complexity.ProductAggregate.Varieties(childComplexity), true

	case "Purchase.date":
		if e.complexity.Purchase.Date == nil {
			break
		}

		return e.complexity.Purchase.Date(childComplexity), true

	case "Purchase.id":
		if e.complexity.Purchase.ID == nil {
			break
		}

		return e.complexity.Purchase.ID(childComplexity), true

	case "Purchase.notes":
		if e.complexity.Purchase.Notes == nil {
			break
		}

		return e.complexity.Purchase.Notes(childComplexity), true

	case "Purchase.price":
		if e.complexity.Purchase.Price == nil {
			break
		}

		return e.complexity.Purchase.Price(childComplexity), true

	case "Purchase.quantity":
		if e.complexity.Purchase.Quantity == nil {
			break
		}

		return e.complexity.Purchase.Quantity(childComplexity), true

	case "Purchase.retailer":
		if e.complexity.Purchase.Retailer == nil {
			break
		}

		return e.complexity.Purchase.Retailer(childComplexity), true

	case "Purchase.unit":
		if e.complexity.Purchase.Unit == nil {
			break
		}

		return e.complexity.Purchase.Unit(childComplexity), true

	case "Query.preparedRecipe":
		if e.complexity.Query.PreparedRecipe == nil {
			break
		}

		args, err := ec.field_Query_preparedRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreparedRecipe(childComplexity, args["recipeName"].(string), args["date"].(string)), true

	case "Query.preparedRecipesByDate":
		if e.complexity.Query.PreparedRecipesByDate == nil {
			break
		}

		args, err := ec.field_Query_preparedRecipesByDate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreparedRecipesByDate(childComplexity, args["date"].(string)), true

	case "Query.productAggregate":
		if e.complexity.Query.ProductAggregate == nil {
			break
		}

		args, err := ec.field_Query_productAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProductAggregate(childComplexity, args["id"].(string)), true

	case "Query.products":
		if e.complexity.Query.Products == nil {
			break
		}

		return e.complexity.Query.Products(childComplexity), true

	case "Query.recipe":
		if e.complexity.Query.Recipe == nil {
			break
		}

		args, err := ec.field_Query_recipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Recipe(childComplexity, args["recipeName"].(string)), true

	case "Query.recipes":
		if e.complexity.Query.Recipes == nil {
			break
		}

		return e.complexity.Query.Recipes(childComplexity), true

	case "RecipeAggregate.ingredients":
		if e.complexity.RecipeAggregate.Ingredients == nil {
			break
		}

		return e.complexity.RecipeAggregate.Ingredients(childComplexity), true

	case "RecipeAggregate.notes":
		if e.complexity.RecipeAggregate.Notes == nil {
			break
		}

		return e.complexity.RecipeAggregate.Notes(childComplexity), true

	case "RecipeAggregate.recipeName":
		if e.complexity.RecipeAggregate.RecipeName == nil {
			break
		}

		return e.complexity.RecipeAggregate.RecipeName(childComplexity), true

	case "RecipeAggregate.steps":
		if e.complexity.RecipeAggregate.Steps == nil {
			break
		}

		return e.complexity.RecipeAggregate.Steps(childComplexity), true

	case "Variety.nutritionalValue":
		if e.complexity.Variety.NutritionalValue == nil {
			break
		}

		return e.complexity.Variety.NutritionalValue(childComplexity), true

	case "Variety.purchases":
		if e.complexity.Variety.Purchases == nil {
			break
		}

		return e.complexity.Variety.Purchases(childComplexity), true

	case "Variety.varietyName":
		if e.complexity.Variety.VarietyName == nil {
			break
		}

		return e.complexity.Variety.VarietyName(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputIngredientInput,
		ec.unmarshalInputNutritionalValueInput,
		ec.unmarshalInputPlanRecipe,
		ec.unmarshalInputPreparedRecipeInput,
		ec.unmarshalInputProductAggregateInput,
		ec.unmarshalInputPurchaseInput,
		ec.unmarshalInputRecipeInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "product.graphqls" "recipe.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "product.graphqls", Input: sourceData("product.graphqls"), BuiltIn: false},
	{Name: "recipe.graphqls", Input: sourceData("recipe.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
