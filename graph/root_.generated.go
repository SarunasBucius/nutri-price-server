// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/SarunasBucius/nutri-price-server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CalculatedDay struct {
		Carbohydrate       func(childComplexity int) int
		CarbohydrateSugars func(childComplexity int) int
		Date               func(childComplexity int) int
		EnergyValueKcal    func(childComplexity int) int
		Fat                func(childComplexity int) int
		Fibre              func(childComplexity int) int
		Price              func(childComplexity int) int
		Protein            func(childComplexity int) int
		Recipes            func(childComplexity int) int
		Salt               func(childComplexity int) int
		SaturatedFat       func(childComplexity int) int
	}

	CalculatedProduct struct {
		Carbohydrate       func(childComplexity int) int
		CarbohydrateSugars func(childComplexity int) int
		EnergyValueKcal    func(childComplexity int) int
		Fat                func(childComplexity int) int
		Fibre              func(childComplexity int) int
		Price              func(childComplexity int) int
		Product            func(childComplexity int) int
		Protein            func(childComplexity int) int
		Quantity           func(childComplexity int) int
		Salt               func(childComplexity int) int
		SaturatedFat       func(childComplexity int) int
		Unit               func(childComplexity int) int
		VarietyName        func(childComplexity int) int
	}

	CalculatedRecipe struct {
		Carbohydrate       func(childComplexity int) int
		CarbohydrateSugars func(childComplexity int) int
		EnergyValueKcal    func(childComplexity int) int
		Fat                func(childComplexity int) int
		Fibre              func(childComplexity int) int
		Portion            func(childComplexity int) int
		Price              func(childComplexity int) int
		Products           func(childComplexity int) int
		Protein            func(childComplexity int) int
		RecipeName         func(childComplexity int) int
		Salt               func(childComplexity int) int
		SaturatedFat       func(childComplexity int) int
	}

	Ingredient struct {
		Notes    func(childComplexity int) int
		Product  func(childComplexity int) int
		Quantity func(childComplexity int) int
		Unit     func(childComplexity int) int
	}

	Mutation struct {
		CreateProduct          func(childComplexity int, input model.ProductAggregateInput) int
		DeleteNutritionalValue func(childComplexity int, id string) int
		DeleteProduct          func(childComplexity int, id string) int
		DeletePurchase         func(childComplexity int, id string) int
		DeleteVariety          func(childComplexity int, varietyName string) int
		PlanRecipes            func(childComplexity int, date string, planRecipes []*model.PlanRecipe) int
		UpdatePreparedRecipe   func(childComplexity int, recipe model.PreparedRecipeInput) int
		UpdateProduct          func(childComplexity int, id string, name string) int
		UpdatePurchase         func(childComplexity int, id string, input model.PurchaseInput) int
		UpdateRecipe           func(childComplexity int, recipe model.RecipeInput) int
		UpdateVariety          func(childComplexity int, oldName string, varietyName string) int
		UpsertNutritionalValue func(childComplexity int, productID string, varietyName string, input model.NutritionalValueInput) int
	}

	NutritionalValue struct {
		Carbohydrate       func(childComplexity int) int
		CarbohydrateSugars func(childComplexity int) int
		EnergyValueKcal    func(childComplexity int) int
		Fat                func(childComplexity int) int
		Fibre              func(childComplexity int) int
		ID                 func(childComplexity int) int
		Protein            func(childComplexity int) int
		Salt               func(childComplexity int) int
		SaturatedFat       func(childComplexity int) int
		Unit               func(childComplexity int) int
	}

	PreparedRecipeAggregate struct {
		Ingredients  func(childComplexity int) int
		Notes        func(childComplexity int) int
		Portion      func(childComplexity int) int
		PreparedDate func(childComplexity int) int
		RecipeName   func(childComplexity int) int
		Steps        func(childComplexity int) int
	}

	Product struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	ProductAggregate struct {
		Name      func(childComplexity int) int
		Varieties func(childComplexity int) int
	}

	Purchase struct {
		Date     func(childComplexity int) int
		ID       func(childComplexity int) int
		Notes    func(childComplexity int) int
		Price    func(childComplexity int) int
		Quantity func(childComplexity int) int
		Retailer func(childComplexity int) int
		Unit     func(childComplexity int) int
	}

	Query struct {
		CalculateDaysConsumption func(childComplexity int, date string) int
		PreparedRecipe           func(childComplexity int, recipeName string, date string) int
		PreparedRecipesByDate    func(childComplexity int, date string) int
		ProductAggregate         func(childComplexity int, id string) int
		Products                 func(childComplexity int) int
		Recipe                   func(childComplexity int, recipeName string) int
		Recipes                  func(childComplexity int) int
	}

	RecipeAggregate struct {
		Ingredients func(childComplexity int) int
		IsFavorite  func(childComplexity int) int
		Notes       func(childComplexity int) int
		RecipeName  func(childComplexity int) int
		Steps       func(childComplexity int) int
	}

	Variety struct {
		NutritionalValue func(childComplexity int) int
		Purchases        func(childComplexity int) int
		VarietyName      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CalculatedDay.carbohydrate":
		if e.complexity.CalculatedDay.Carbohydrate == nil {
			break
		}

		return e.complexity.CalculatedDay.Carbohydrate(childComplexity), true

	case "CalculatedDay.carbohydrateSugars":
		if e.complexity.CalculatedDay.CarbohydrateSugars == nil {
			break
		}

		return e.complexity.CalculatedDay.CarbohydrateSugars(childComplexity), true

	case "CalculatedDay.date":
		if e.complexity.CalculatedDay.Date == nil {
			break
		}

		return e.complexity.CalculatedDay.Date(childComplexity), true

	case "CalculatedDay.energyValueKcal":
		if e.complexity.CalculatedDay.EnergyValueKcal == nil {
			break
		}

		return e.complexity.CalculatedDay.EnergyValueKcal(childComplexity), true

	case "CalculatedDay.fat":
		if e.complexity.CalculatedDay.Fat == nil {
			break
		}

		return e.complexity.CalculatedDay.Fat(childComplexity), true

	case "CalculatedDay.fibre":
		if e.complexity.CalculatedDay.Fibre == nil {
			break
		}

		return e.complexity.CalculatedDay.Fibre(childComplexity), true

	case "CalculatedDay.price":
		if e.complexity.CalculatedDay.Price == nil {
			break
		}

		return e.complexity.CalculatedDay.Price(childComplexity), true

	case "CalculatedDay.protein":
		if e.complexity.CalculatedDay.Protein == nil {
			break
		}

		return e.complexity.CalculatedDay.Protein(childComplexity), true

	case "CalculatedDay.recipes":
		if e.complexity.CalculatedDay.Recipes == nil {
			break
		}

		return e.complexity.CalculatedDay.Recipes(childComplexity), true

	case "CalculatedDay.salt":
		if e.complexity.CalculatedDay.Salt == nil {
			break
		}

		return e.complexity.CalculatedDay.Salt(childComplexity), true

	case "CalculatedDay.saturatedFat":
		if e.complexity.CalculatedDay.SaturatedFat == nil {
			break
		}

		return e.complexity.CalculatedDay.SaturatedFat(childComplexity), true

	case "CalculatedProduct.carbohydrate":
		if e.complexity.CalculatedProduct.Carbohydrate == nil {
			break
		}

		return e.complexity.CalculatedProduct.Carbohydrate(childComplexity), true

	case "CalculatedProduct.carbohydrateSugars":
		if e.complexity.CalculatedProduct.CarbohydrateSugars == nil {
			break
		}

		return e.complexity.CalculatedProduct.CarbohydrateSugars(childComplexity), true

	case "CalculatedProduct.energyValueKcal":
		if e.complexity.CalculatedProduct.EnergyValueKcal == nil {
			break
		}

		return e.complexity.CalculatedProduct.EnergyValueKcal(childComplexity), true

	case "CalculatedProduct.fat":
		if e.complexity.CalculatedProduct.Fat == nil {
			break
		}

		return e.complexity.CalculatedProduct.Fat(childComplexity), true

	case "CalculatedProduct.fibre":
		if e.complexity.CalculatedProduct.Fibre == nil {
			break
		}

		return e.complexity.CalculatedProduct.Fibre(childComplexity), true

	case "CalculatedProduct.price":
		if e.complexity.CalculatedProduct.Price == nil {
			break
		}

		return e.complexity.CalculatedProduct.Price(childComplexity), true

	case "CalculatedProduct.product":
		if e.complexity.CalculatedProduct.Product == nil {
			break
		}

		return e.complexity.CalculatedProduct.Product(childComplexity), true

	case "CalculatedProduct.protein":
		if e.complexity.CalculatedProduct.Protein == nil {
			break
		}

		return e.complexity.CalculatedProduct.Protein(childComplexity), true

	case "CalculatedProduct.quantity":
		if e.complexity.CalculatedProduct.Quantity == nil {
			break
		}

		return e.complexity.CalculatedProduct.Quantity(childComplexity), true

	case "CalculatedProduct.salt":
		if e.complexity.CalculatedProduct.Salt == nil {
			break
		}

		return e.complexity.CalculatedProduct.Salt(childComplexity), true

	case "CalculatedProduct.saturatedFat":
		if e.complexity.CalculatedProduct.SaturatedFat == nil {
			break
		}

		return e.complexity.CalculatedProduct.SaturatedFat(childComplexity), true

	case "CalculatedProduct.unit":
		if e.complexity.CalculatedProduct.Unit == nil {
			break
		}

		return e.complexity.CalculatedProduct.Unit(childComplexity), true

	case "CalculatedProduct.varietyName":
		if e.complexity.CalculatedProduct.VarietyName == nil {
			break
		}

		return e.complexity.CalculatedProduct.VarietyName(childComplexity), true

	case "CalculatedRecipe.carbohydrate":
		if e.complexity.CalculatedRecipe.Carbohydrate == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Carbohydrate(childComplexity), true

	case "CalculatedRecipe.carbohydrateSugars":
		if e.complexity.CalculatedRecipe.CarbohydrateSugars == nil {
			break
		}

		return e.complexity.CalculatedRecipe.CarbohydrateSugars(childComplexity), true

	case "CalculatedRecipe.energyValueKcal":
		if e.complexity.CalculatedRecipe.EnergyValueKcal == nil {
			break
		}

		return e.complexity.CalculatedRecipe.EnergyValueKcal(childComplexity), true

	case "CalculatedRecipe.fat":
		if e.complexity.CalculatedRecipe.Fat == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Fat(childComplexity), true

	case "CalculatedRecipe.fibre":
		if e.complexity.CalculatedRecipe.Fibre == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Fibre(childComplexity), true

	case "CalculatedRecipe.portion":
		if e.complexity.CalculatedRecipe.Portion == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Portion(childComplexity), true

	case "CalculatedRecipe.price":
		if e.complexity.CalculatedRecipe.Price == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Price(childComplexity), true

	case "CalculatedRecipe.products":
		if e.complexity.CalculatedRecipe.Products == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Products(childComplexity), true

	case "CalculatedRecipe.protein":
		if e.complexity.CalculatedRecipe.Protein == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Protein(childComplexity), true

	case "CalculatedRecipe.recipeName":
		if e.complexity.CalculatedRecipe.RecipeName == nil {
			break
		}

		return e.complexity.CalculatedRecipe.RecipeName(childComplexity), true

	case "CalculatedRecipe.salt":
		if e.complexity.CalculatedRecipe.Salt == nil {
			break
		}

		return e.complexity.CalculatedRecipe.Salt(childComplexity), true

	case "CalculatedRecipe.saturatedFat":
		if e.complexity.CalculatedRecipe.SaturatedFat == nil {
			break
		}

		return e.complexity.CalculatedRecipe.SaturatedFat(childComplexity), true

	case "Ingredient.notes":
		if e.complexity.Ingredient.Notes == nil {
			break
		}

		return e.complexity.Ingredient.Notes(childComplexity), true

	case "Ingredient.product":
		if e.complexity.Ingredient.Product == nil {
			break
		}

		return e.complexity.Ingredient.Product(childComplexity), true

	case "Ingredient.quantity":
		if e.complexity.Ingredient.Quantity == nil {
			break
		}

		return e.complexity.Ingredient.Quantity(childComplexity), true

	case "Ingredient.unit":
		if e.complexity.Ingredient.Unit == nil {
			break
		}

		return e.complexity.Ingredient.Unit(childComplexity), true

	case "Mutation.createProduct":
		if e.complexity.Mutation.CreateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_createProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProduct(childComplexity, args["input"].(model.ProductAggregateInput)), true

	case "Mutation.deleteNutritionalValue":
		if e.complexity.Mutation.DeleteNutritionalValue == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNutritionalValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNutritionalValue(childComplexity, args["id"].(string)), true

	case "Mutation.deleteProduct":
		if e.complexity.Mutation.DeleteProduct == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProduct(childComplexity, args["id"].(string)), true

	case "Mutation.deletePurchase":
		if e.complexity.Mutation.DeletePurchase == nil {
			break
		}

		args, err := ec.field_Mutation_deletePurchase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePurchase(childComplexity, args["id"].(string)), true

	case "Mutation.deleteVariety":
		if e.complexity.Mutation.DeleteVariety == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVariety_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVariety(childComplexity, args["varietyName"].(string)), true

	case "Mutation.planRecipes":
		if e.complexity.Mutation.PlanRecipes == nil {
			break
		}

		args, err := ec.field_Mutation_planRecipes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PlanRecipes(childComplexity, args["date"].(string), args["planRecipes"].([]*model.PlanRecipe)), true

	case "Mutation.updatePreparedRecipe":
		if e.complexity.Mutation.UpdatePreparedRecipe == nil {
			break
		}

		args, err := ec.field_Mutation_updatePreparedRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePreparedRecipe(childComplexity, args["recipe"].(model.PreparedRecipeInput)), true

	case "Mutation.updateProduct":
		if e.complexity.Mutation.UpdateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_updateProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProduct(childComplexity, args["id"].(string), args["name"].(string)), true

	case "Mutation.updatePurchase":
		if e.complexity.Mutation.UpdatePurchase == nil {
			break
		}

		args, err := ec.field_Mutation_updatePurchase_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePurchase(childComplexity, args["id"].(string), args["input"].(model.PurchaseInput)), true

	case "Mutation.updateRecipe":
		if e.complexity.Mutation.UpdateRecipe == nil {
			break
		}

		args, err := ec.field_Mutation_updateRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRecipe(childComplexity, args["recipe"].(model.RecipeInput)), true

	case "Mutation.updateVariety":
		if e.complexity.Mutation.UpdateVariety == nil {
			break
		}

		args, err := ec.field_Mutation_updateVariety_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVariety(childComplexity, args["oldName"].(string), args["varietyName"].(string)), true

	case "Mutation.upsertNutritionalValue":
		if e.complexity.Mutation.UpsertNutritionalValue == nil {
			break
		}

		args, err := ec.field_Mutation_upsertNutritionalValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpsertNutritionalValue(childComplexity, args["productID"].(string), args["varietyName"].(string), args["input"].(model.NutritionalValueInput)), true

	case "NutritionalValue.carbohydrate":
		if e.complexity.NutritionalValue.Carbohydrate == nil {
			break
		}

		return e.complexity.NutritionalValue.Carbohydrate(childComplexity), true

	case "NutritionalValue.carbohydrateSugars":
		if e.complexity.NutritionalValue.CarbohydrateSugars == nil {
			break
		}

		return e.complexity.NutritionalValue.CarbohydrateSugars(childComplexity), true

	case "NutritionalValue.energyValueKcal":
		if e.complexity.NutritionalValue.EnergyValueKcal == nil {
			break
		}

		return e.complexity.NutritionalValue.EnergyValueKcal(childComplexity), true

	case "NutritionalValue.fat":
		if e.complexity.NutritionalValue.Fat == nil {
			break
		}

		return e.complexity.NutritionalValue.Fat(childComplexity), true

	case "NutritionalValue.fibre":
		if e.complexity.NutritionalValue.Fibre == nil {
			break
		}

		return e.complexity.NutritionalValue.Fibre(childComplexity), true

	case "NutritionalValue.id":
		if e.complexity.NutritionalValue.ID == nil {
			break
		}

		return e.complexity.NutritionalValue.ID(childComplexity), true

	case "NutritionalValue.protein":
		if e.complexity.NutritionalValue.Protein == nil {
			break
		}

		return e.complexity.NutritionalValue.Protein(childComplexity), true

	case "NutritionalValue.salt":
		if e.complexity.NutritionalValue.Salt == nil {
			break
		}

		return e.complexity.NutritionalValue.Salt(childComplexity), true

	case "NutritionalValue.saturatedFat":
		if e.complexity.NutritionalValue.SaturatedFat == nil {
			break
		}

		return e.complexity.NutritionalValue.SaturatedFat(childComplexity), true

	case "NutritionalValue.unit":
		if e.complexity.NutritionalValue.Unit == nil {
			break
		}

		return e.complexity.NutritionalValue.Unit(childComplexity), true

	case "PreparedRecipeAggregate.ingredients":
		if e.complexity.PreparedRecipeAggregate.Ingredients == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Ingredients(childComplexity), true

	case "PreparedRecipeAggregate.notes":
		if e.complexity.PreparedRecipeAggregate.Notes == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Notes(childComplexity), true

	case "PreparedRecipeAggregate.portion":
		if e.complexity.PreparedRecipeAggregate.Portion == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Portion(childComplexity), true

	case "PreparedRecipeAggregate.preparedDate":
		if e.complexity.PreparedRecipeAggregate.PreparedDate == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.PreparedDate(childComplexity), true

	case "PreparedRecipeAggregate.recipeName":
		if e.complexity.PreparedRecipeAggregate.RecipeName == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.RecipeName(childComplexity), true

	case "PreparedRecipeAggregate.steps":
		if e.complexity.PreparedRecipeAggregate.Steps == nil {
			break
		}

		return e.complexity.PreparedRecipeAggregate.Steps(childComplexity), true

	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true

	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "ProductAggregate.name":
		if e.complexity.ProductAggregate.Name == nil {
			break
		}

		return e.complexity.ProductAggregate.Name(childComplexity), true

	case "ProductAggregate.varieties":
		if e.complexity.ProductAggregate.Varieties == nil {
			break
		}

		return e.complexity.ProductAggregate.Varieties(childComplexity), true

	case "Purchase.date":
		if e.complexity.Purchase.Date == nil {
			break
		}

		return e.complexity.Purchase.Date(childComplexity), true

	case "Purchase.id":
		if e.complexity.Purchase.ID == nil {
			break
		}

		return e.complexity.Purchase.ID(childComplexity), true

	case "Purchase.notes":
		if e.complexity.Purchase.Notes == nil {
			break
		}

		return e.complexity.Purchase.Notes(childComplexity), true

	case "Purchase.price":
		if e.complexity.Purchase.Price == nil {
			break
		}

		return e.complexity.Purchase.Price(childComplexity), true

	case "Purchase.quantity":
		if e.complexity.Purchase.Quantity == nil {
			break
		}

		return e.complexity.Purchase.Quantity(childComplexity), true

	case "Purchase.retailer":
		if e.complexity.Purchase.Retailer == nil {
			break
		}

		return e.complexity.Purchase.Retailer(childComplexity), true

	case "Purchase.unit":
		if e.complexity.Purchase.Unit == nil {
			break
		}

		return e.complexity.Purchase.Unit(childComplexity), true

	case "Query.calculateDaysConsumption":
		if e.complexity.Query.CalculateDaysConsumption == nil {
			break
		}

		args, err := ec.field_Query_calculateDaysConsumption_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CalculateDaysConsumption(childComplexity, args["date"].(string)), true

	case "Query.preparedRecipe":
		if e.complexity.Query.PreparedRecipe == nil {
			break
		}

		args, err := ec.field_Query_preparedRecipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreparedRecipe(childComplexity, args["recipeName"].(string), args["date"].(string)), true

	case "Query.preparedRecipesByDate":
		if e.complexity.Query.PreparedRecipesByDate == nil {
			break
		}

		args, err := ec.field_Query_preparedRecipesByDate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreparedRecipesByDate(childComplexity, args["date"].(string)), true

	case "Query.productAggregate":
		if e.complexity.Query.ProductAggregate == nil {
			break
		}

		args, err := ec.field_Query_productAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProductAggregate(childComplexity, args["id"].(string)), true

	case "Query.products":
		if e.complexity.Query.Products == nil {
			break
		}

		return e.complexity.Query.Products(childComplexity), true

	case "Query.recipe":
		if e.complexity.Query.Recipe == nil {
			break
		}

		args, err := ec.field_Query_recipe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Recipe(childComplexity, args["recipeName"].(string)), true

	case "Query.recipes":
		if e.complexity.Query.Recipes == nil {
			break
		}

		return e.complexity.Query.Recipes(childComplexity), true

	case "RecipeAggregate.ingredients":
		if e.complexity.RecipeAggregate.Ingredients == nil {
			break
		}

		return e.complexity.RecipeAggregate.Ingredients(childComplexity), true

	case "RecipeAggregate.isFavorite":
		if e.complexity.RecipeAggregate.IsFavorite == nil {
			break
		}

		return e.complexity.RecipeAggregate.IsFavorite(childComplexity), true

	case "RecipeAggregate.notes":
		if e.complexity.RecipeAggregate.Notes == nil {
			break
		}

		return e.complexity.RecipeAggregate.Notes(childComplexity), true

	case "RecipeAggregate.recipeName":
		if e.complexity.RecipeAggregate.RecipeName == nil {
			break
		}

		return e.complexity.RecipeAggregate.RecipeName(childComplexity), true

	case "RecipeAggregate.steps":
		if e.complexity.RecipeAggregate.Steps == nil {
			break
		}

		return e.complexity.RecipeAggregate.Steps(childComplexity), true

	case "Variety.nutritionalValue":
		if e.complexity.Variety.NutritionalValue == nil {
			break
		}

		return e.complexity.Variety.NutritionalValue(childComplexity), true

	case "Variety.purchases":
		if e.complexity.Variety.Purchases == nil {
			break
		}

		return e.complexity.Variety.Purchases(childComplexity), true

	case "Variety.varietyName":
		if e.complexity.Variety.VarietyName == nil {
			break
		}

		return e.complexity.Variety.VarietyName(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputIngredientInput,
		ec.unmarshalInputNutritionalValueInput,
		ec.unmarshalInputPlanRecipe,
		ec.unmarshalInputPreparedRecipeInput,
		ec.unmarshalInputProductAggregateInput,
		ec.unmarshalInputPurchaseInput,
		ec.unmarshalInputRecipeInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "product.graphqls" "recipe.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "product.graphqls", Input: sourceData("product.graphqls"), BuiltIn: false},
	{Name: "recipe.graphqls", Input: sourceData("recipe.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
